#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <cstring>
#include <iostream>
#include <string>
#include <iomanip>
#include <sstream>
#include "eval.h"
#include <signal.h>
#include <sys/wait.h>

//@author Timothy Bartolo
//811847393

/* program simulates the input
 * screen of the UNIX terminal.
 * processes, pipelines, and
 * files are read accordingly
 */
using namespace std;

eval get_input_info();
string get_prompt();

/* main takes in user input and
 * passes it to eval class. Then
 * calls getter functions to display
 * all information regarding commands
 */
int main(int argc, const char *argv[]){

  cout.setf(std::ios_base::unitbuf); //turn off buffering for cout
  pid_t pid, wpid; //various PIDs
  int pstatus; //process pstatus

  while(true){ //shell infinite loop
    eval *ev = new eval(get_input_info()); //get user input information
    string *arg_v = ev -> get_argv();

    if(ev -> get_procs() == 0){ //check for other commands other than processes
      if(arg_v[0] == "exit"){ //exit
	if(ev -> get_argc() == 2){ //exit (int)
	  exit(stoi(arg_v[1]));
	} //if
	else{ //exit (no int)
	  exit(pstatus);
	} //else
      } //if
      else if(arg_v[0] == "cd"){ //cd
	if(ev -> get_argc() > 2){
	  printf("%s: invalid argument length\n", arg_v[0].c_str());
	} //if
	else if(ev -> get_argc() == 1){
	  chdir(getenv("HOME"));
	} //else if
	else if(chdir(arg_v[1].c_str()) < 0){
	  perror("change directory");
	} //if
      } //else if
      else if(arg_v[0] == "help"){ //help
	//TODO implement help information
      } //else if 
      
      delete ev; //call deconstructor to reset variables
      continue; //go to while loop
    } //if

    for(int numProc = 0; numProc <= ev -> get_pipes(); numProc++){ //loop on number of processes
      if((pid = fork()) < 0) { // error 
	perror("FORK ERROR");
      } //if
      else if (pid == 0) { //child
	string *arg_v1 = ev -> get_process(numProc);
	char **args = new char *[ev -> get_process_args(numProc)];

	for(int j = 0; j < ev -> get_process_args(numProc); j++){
	  args[j] = strdup(arg_v1[j].c_str());
	} //for 

	args[ev -> get_process_args(numProc)] = nullptr; //last element is \0
	execvp(args[0], args);
	
	perror("execvp"); //if execvp fail
	exit(EXIT_FAILURE);
      } //else if (child)
      else{ //parent
	bool dead = false;

	signal(SIGTSTP, SIG_IGN); //ignore ctrl-z
	//TODO add other signals to ignore
      
	while(!dead){
	  if ((wpid = wait(&pstatus) == -1)) {
	    perror("waitpid");
	    dead = true;
	  } //if
	  else if (WIFEXITED(pstatus)){ //if child process exits
	    cout << "\n" <<  pid << " Exited (" << WEXITSTATUS(pstatus) << ") emacs\n";
	    dead = true;
	  } //else if child exited
	  else if (WIFSIGNALED(pstatus)){ ///if child process returns signal
	    int sig = WTERMSIG(pstatus);
	    cout << "\n" <<  pid << " Exited (" << strsignal(sig) << ") emacs\n";
	    dead = true;
	  } //else if child signaled
	  else if(WIFSTOPPED(pstatus)){
	    cout << "\n" <<  pid << " Stopped ";
	    for(int n = 0; n < ev -> get_process_args(numProc); n++){
	      cout << ev -> get_process(numProc)[n] << " ";
	    } //for
	    cout << "\n";
	  } //else if
	  else if(WIFCONTINUED(pstatus)){
	    cout << "\n" <<  pid << " Continued ";
	    for(int n = 0; n < ev -> get_process_args(numProc); n++){
	      cout << ev -> get_process(numProc)[n] << " ";
	    } //for
	    cout << "\n";
	  } //else if
	} //while (parent)
      } //else (parent)
     } //for
     delete ev; //call deconstructor to reset variables
  } //while (shell)
} //main

/* function displays prompt to user and
 * sends user input to the evaluate class
 * to break it down into useful information
 */
eval get_input_info(){

  string input;
  string word;
  int total_args = 1;
  string prompt;

  prompt = get_prompt();
  
  while(input.empty()){ //if user enters just ENTER
    cout << prompt;
    getline(cin, input); //store string in input
  } //while

  string input_args[100];
  const char *args[100];
    
  istringstream iss(input);
    
  while(iss >> word) {
    input_args[total_args] = word;
    total_args++;
  } //while
  
  for(int i = 0; i < total_args; i++){
    args[i] = input_args[i].c_str();
  } //for
    
  eval ev(total_args, args);
  return ev;
} //get_input_info

/* function updates the user
 * prompt to the current working
 * directory each time it is called
 */
string get_prompt(){

  const char *path;
  string the_prompt = "1730sh: ";

  path = get_current_dir_name();
  string the_path(path);

  if(the_path.find(getenv("HOME")) != string::npos){ //if the path contains the HOME dir
    the_path.erase(0, strlen(getenv("HOME"))); //erase HOME dir from path
    the_prompt += "~";
  } //if

  the_prompt += the_path;
  the_prompt += "$ ";

  return the_prompt;
} //get_prompt
